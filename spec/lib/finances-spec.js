// Generated by CoffeeScript 1.6.2
(function() {
  var root,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = this;

  Array.prototype.where = function(object) {
    return _(this).where(object);
  };

  Array.prototype.contains = function(object) {
    return this.where(object).length > 0;
  };

  describe("finances", function() {
    var a1, a2, a3, i, i1, i2, i3, s, _ref;

    _ref = (function() {
      var _i, _results;

      _results = [];
      for (i = _i = 1; _i <= 7; i = ++_i) {
        _results.push(null);
      }
      return _results;
    })(), s = _ref[0], a1 = _ref[1], a2 = _ref[2], a3 = _ref[3], i1 = _ref[4], i2 = _ref[5], i3 = _ref[6];
    beforeEach(function() {
      root.AccountCollection = new Meteor.Collection(null, {
        transform: function(doc) {
          return s.createAccount(doc);
        }
      });
      root.ItemCollection = new Meteor.Collection(null, {
        transform: function(doc) {
          return s.createItem(doc);
        }
      });
      root.PaymentCollection = new Meteor.Collection(null, {
        transform: function(doc) {
          return s.createPayment(doc);
        }
      });
      root.UsageCollection = new Meteor.Collection(null, {
        transform: function(doc) {
          return s.createUsage(doc);
        }
      });
      s = new finances.Scenario({
        createAccount: function(doc) {
          AccountCollection.upsert(doc._id, {
            $set: doc
          });
          return new finances.Account(_.extend(doc, {
            scenario: this
          }));
        },
        createItem: function(doc) {
          ItemCollection.upsert(doc._id, {
            $set: doc
          });
          return new finances.Item(_.extend(doc, {
            scenario: this
          }));
        },
        createPayment: function(doc) {
          PaymentCollection.upsert(doc._id, {
            $set: doc
          });
          return new finances.Payment(_.extend(doc, {
            scenario: this
          }));
        },
        createUsage: function(doc) {
          UsageCollection.upsert(doc._id, {
            $set: doc
          });
          return new finances.Usage(_.extend(doc, {
            scenario: this
          }));
        },
        findAccounts: function(sel) {
          return AccountCollection.find(sel).fetch();
        },
        findAccount: function(sel) {
          return AccountCollection.findOne(sel);
        },
        findItems: function(sel) {
          return ItemCollection.find(sel).fetch();
        },
        findItem: function(sel) {
          return ItemCollection.findOne(sel);
        },
        findPayments: function(sel) {
          return PaymentCollection.find(sel).fetch();
        },
        findPayment: function(sel) {
          return PaymentCollection.findOne(sel);
        },
        findUsages: function(sel) {
          return UsageCollection.find(sel).fetch();
        },
        findUsage: function(sel) {
          return UsageCollection.findOne(sel);
        },
        savePayment: function(doc) {
          return this.createPayment(doc);
        },
        deletePayment: function(doc) {
          return PaymentCollection.remove(doc._id);
        }
      });
      a1 = s.createAccount({
        name: 'Fred'
      });
      a2 = s.createAccount({
        name: 'Dafny'
      });
      a3 = s.createAccount({
        name: 'Shaggy/Scooby'
      });
      i1 = s.createItem({
        name: 'dinner',
        amount: 60
      });
      i2 = s.createItem({
        name: 'costume',
        amount: 25
      });
      return i3 = s.createItem({
        name: 'snacks',
        amount: 12
      });
    });
    it('should be groovy', function() {
      return expect(finances).toBeDefined();
    });
    it('should track users', function() {
      var users;

      a1.uses(i1);
      a2.uses(i1);
      users = s.findUsers(i1.toJSON());
      return expect(users.contains(a1)).toBe(true);
    });
    it('should track payments', function() {
      var accounts, p;

      a1.pays(i1, 50);
      a2.pays(i1, 50);
      accounts = (function() {
        var _i, _len, _ref1, _results;

        _ref1 = s.findPayments({
          item: i1.toJSON()
        });
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          _results.push(p.fromAccount);
        }
        return _results;
      })();
      expect(__indexOf.call(accounts, a1) >= 0);
      return expect(__indexOf.call(accounts, a2) >= 0);
    });
    describe('when settling debts', function() {
      it('should ignore equal and opposite debts', function() {
        i2 = i1.clone('b-fast');
        a1.paysAndUses(i1);
        a2.paysAndUses(i2);
        a1.uses(i2);
        a2.uses(i1);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a1.crunch().total).toBe(0);
        return expect(a2.crunch().total).toBe(0);
      });
      it('should ignore debts to and from the same Account', function() {
        a1.paysAndUses(i1);
        s.createInternalPayments();
        s.simplifyPayments();
        return expect(a1.crunch().total).toBe(0);
      });
      it('should ignore larger cycles of equal debts', function() {
        i2 = i1.clone('b-fast');
        i3 = i1.clone('lunch');
        a1.paysAndUses(i1);
        a2.uses(i1);
        a2.paysAndUses(i2);
        a3.uses(i2);
        a3.paysAndUses(i3);
        a1.uses(i3);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a1.crunch().total).toBe(0);
        expect(a2.crunch().total).toBe(0);
        return expect(a3.crunch().total).toBe(0);
      });
      it('should replace debts along the same path with one direct debt', function() {
        i2 = i1.clone('b-fast');
        a1.paysAndUses(i1);
        a2.uses(i1);
        a2.paysAndUses(i2);
        a3.uses(i2);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a3.crunch().total).toBe(i2.amount / 2);
        expect(a2.crunch().total).toBe(0);
        return expect(a1.crunch().total).toBe(0);
      });
      return describe('when all debts are not equal', function() {
        describe('when the first debt in the path is bigger', function() {
          return it('should reduce debts along a given path and create a direct debt', function() {
            i2 = s.createItem({
              name: 'dessert',
              amount: i1.amount + 5
            });
            a1.paysAndUses(i1);
            a2.uses(i1);
            a2.paysAndUses(i2);
            a3.uses(i2);
            s.createInternalPayments();
            s.simplifyPayments();
            expect(a3.crunch().total).toBe(i2.amount / 2);
            expect(a2.crunch().total).toBe(0);
            return expect(a1.crunch().total).toBe(0);
          });
        });
        return describe('when the second debt in the path is bigger', function() {
          return it('should reduce debts along a given path and create a direct debt', function() {
            i2 = s.createItem({
              name: 'dessert',
              amount: i1.amount + 5
            });
            a1.paysAndUses(i2);
            a2.uses(i2);
            a2.paysAndUses(i1);
            a3.uses(i1);
            s.createInternalPayments();
            s.simplifyPayments();
            expect(a3.crunch().total).toBe(i1.amount / 2);
            expect(a2.crunch().total).toBe(i2.amount / 2 - i1.amount / 2);
            return expect(a1.crunch().total).toBe(0);
          });
        });
      });
    });
    describe('pseudo-random number generator', function() {
      return it('should always generate the same sequence for a given seed', function() {
        var rng1, rng2, sequence1, sequence2, _i, _j, _k, _results;

        rng1 = finances.getPRNG(42);
        for (i = _i = 1; _i <= 20; i = ++_i) {
          sequence1 = rng1();
        }
        rng2 = finances.getPRNG(42);
        for (i = _j = 1; _j <= 20; i = ++_j) {
          sequence2 = rng2();
        }
        _results = [];
        for (i = _k = 1; _k <= 20; i = ++_k) {
          _results.push(expect(sequence1[i]).toEqual(sequence2[i]));
        }
        return _results;
      });
    });
    return describe('test scenarios', function() {
      var count, findSum, scenarios;

      count = 10;
      findSum = function(list) {
        var add;

        add = function(a, b) {
          return a + b;
        };
        return _.reduce(list, add, 0);
      };
      scenarios = [];
      beforeEach(function() {
        debugger;
        var results, seed;

        return results = (function() {
          var _i, _results;

          _results = [];
          for (seed = _i = 0; _i <= 20; seed = ++_i) {
            _results.push(finances.testScenario(seed, s));
          }
          return _results;
        })();
      });
      it('should have payments', function() {
        var result, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          result = results[_i];
          _results.push(expect(result.totalPayments).toBeGreaterThan(0));
        }
        return _results;
      });
      it('should have all items paid for', function() {
        var p, result, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          result = results[_i];
          expect(result.totalPayments).toBe(findSum((function() {
            var _j, _len1, _ref1, _results1;

            _ref1 = result.items;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              i = _ref1[_j];
              _results1.push(i.amount);
            }
            return _results1;
          })()));
          expect(result.payments.length >= result.items.length).toBeTruthy();
          _results.push((function() {
            var _j, _len1, _ref1, _results1;

            _ref1 = result.items;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              i = _ref1[_j];
              _results1.push(expect(findSum((function() {
                var _k, _len2, _ref2, _results2;

                _ref2 = s.findPayments({
                  item: i.toJSON()
                });
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })())).toBe(i.amount));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should have every account at least either a payer or a user', function() {
        var a, result, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          result = results[_i];
          _results.push((function() {
            var _j, _len1, _ref1, _results1;

            _ref1 = s.accounts;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              a = _ref1[_j];
              _results1.push(expect(a.usesItems.length || a.sendsPayments.length).toBeGreaterThan(0));
            }
            return _results1;
          })());
        }
        return _results;
      });
      return it("should transform to one in which the net amount\nthat each account pays is equal", function() {
        var a, fairShare, p, result, share, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          result = results[_i];
          s.createInternalPayments();
          s.simplifyPayments();
          fairShare = s.totalPayments / s.accounts.length;
          _results.push((function() {
            var _j, _len1, _ref1, _results1;

            _ref1 = s.accounts.length;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              a = _ref1[_j];
              share = findSum(((function() {
                var _k, _len2, _ref2, _results2;

                _ref2 = a.sendsPayments;
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })()) - findSum((function() {
                var _k, _len2, _ref2, _results2;

                _ref2 = a.receivesPayments;
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })()));
              _results1.push(expect(share).toEqual(fairShare));
            }
            return _results1;
          })());
        }
        return _results;
      });
    });
  });

}).call(this);

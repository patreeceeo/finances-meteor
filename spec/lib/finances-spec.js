// Generated by CoffeeScript 1.6.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  describe("finances", function() {
    var Account, Item, Scenario, a1, a2, a3, i, i1, i2, i3, s, _ref;
    _ref = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 7; i = ++_i) {
        _results.push(null);
      }
      return _results;
    })(), s = _ref[0], a1 = _ref[1], a2 = _ref[2], a3 = _ref[3], i1 = _ref[4], i2 = _ref[5], i3 = _ref[6];
    Account = finances.Account;
    Item = finances.Item;
    Scenario = finances.Scenario;
    beforeEach(function() {
      s = new Scenario;
      a1 = s.createAccount({
        name: 'Fred'
      });
      a2 = s.createAccount({
        name: 'Dafny'
      });
      a3 = s.createAccount({
        name: 'Shaggy/Scooby'
      });
      i1 = s.createItem({
        name: 'dinner',
        amount: 60
      });
      i2 = s.createItem({
        name: 'costume',
        amount: 25
      });
      return i3 = s.createItem({
        name: 'snacks',
        amount: 12
      });
    });
    it('should be groovy', function() {
      return expect(finances).toBeDefined();
    });
    it('should track users', function() {
      a1.uses(i1);
      a2.uses(i1);
      expect(__indexOf.call(s.getUsers(i1), a1) >= 0).toBe(true);
      return expect(__indexOf.call(s.getUsers(i1), a2) >= 0).toBe(true);
    });
    it('should track payments', function() {
      var accounts, p;
      a1.pays(i1, 50);
      a2.pays(i1, 50);
      accounts = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = s.getPaymentsForItem(i1);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          _results.push(p.fromAccount);
        }
        return _results;
      })();
      expect(__indexOf.call(accounts, a1) >= 0);
      return expect(__indexOf.call(accounts, a2) >= 0);
    });
    describe('when settling debts', function() {
      it('should ignore equal and opposite debts', function() {
        i2 = i1.clone('b-fast');
        a1.paysAndUses(i1);
        a2.paysAndUses(i2);
        a1.uses(i2);
        a2.uses(i1);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a1.owes().total).toBe(0);
        return expect(a2.owes().total).toBe(0);
      });
      it('should ignore debts to and from the same Account', function() {
        a1.paysAndUses(i1);
        s.createInternalPayments();
        s.simplifyPayments();
        return expect(a1.owes().total).toBe(0);
      });
      it('should ignore larger cycles of equal debts', function() {
        i2 = i1.clone('b-fast');
        i3 = i1.clone('lunch');
        a1.paysAndUses(i1);
        a2.uses(i1);
        a2.paysAndUses(i2);
        a3.uses(i2);
        a3.paysAndUses(i3);
        a1.uses(i3);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a1.owes().total).toBe(0);
        expect(a2.owes().total).toBe(0);
        return expect(a3.owes().total).toBe(0);
      });
      it('should replace debts along the same path with one direct debt', function() {
        i2 = i1.clone('b-fast');
        a1.paysAndUses(i1);
        a2.uses(i1);
        a2.paysAndUses(i2);
        a3.uses(i2);
        s.createInternalPayments();
        s.simplifyPayments();
        expect(a3.owes().total).toBe(i2.amount / 2);
        expect(a2.owes().total).toBe(0);
        return expect(a1.owes().total).toBe(0);
      });
      return describe('when all debts are not equal', function() {
        describe('when the first debt in the path is bigger', function() {
          return it('should reduce debts along a given path and create a direct debt', function() {
            i2 = s.createItem({
              name: 'dessert',
              amount: i1.amount + 5
            });
            a1.paysAndUses(i1);
            a2.uses(i1);
            a2.paysAndUses(i2);
            a3.uses(i2);
            s.createInternalPayments();
            s.simplifyPayments();
            expect(a3.owes().total).toBe(i2.amount / 2);
            expect(a2.owes().total).toBe(0);
            return expect(a1.owes().total).toBe(0);
          });
        });
        return describe('when the second debt in the path is bigger', function() {
          return it('should reduce debts along a given path and create a direct debt', function() {
            i2 = s.createItem({
              name: 'dessert',
              amount: i1.amount + 5
            });
            a1.paysAndUses(i2);
            a2.uses(i2);
            a2.paysAndUses(i1);
            a3.uses(i1);
            s.createInternalPayments();
            s.simplifyPayments();
            expect(a3.owes().total).toBe(i1.amount / 2);
            expect(a2.owes().total).toBe(i2.amount / 2 - i1.amount / 2);
            return expect(a1.owes().total).toBe(0);
          });
        });
      });
    });
    describe('pseudo-random number generator', function() {
      return it('should always generate the same sequence for a given seed', function() {
        var rng1, rng2, sequence1, sequence2, _i, _j, _k, _results;
        rng1 = finances.getPRNG(42);
        for (i = _i = 1; _i <= 20; i = ++_i) {
          sequence1 = rng1();
        }
        rng2 = finances.getPRNG(42);
        for (i = _j = 1; _j <= 20; i = ++_j) {
          sequence2 = rng2();
        }
        _results = [];
        for (i = _k = 1; _k <= 20; i = ++_k) {
          _results.push(expect(sequence1[i]).toEqual(sequence2[i]));
        }
        return _results;
      });
    });
    return describe('test scenarios', function() {
      var count, findSum, scenarios;
      count = 10;
      findSum = function(list) {
        var add;
        add = function(a, b) {
          return a + b;
        };
        return _.reduce(list, add, 0);
      };
      scenarios = [];
      beforeEach(function() {
        var seed;
        return scenarios = (function() {
          var _i, _results;
          _results = [];
          for (seed = _i = 0; _i <= 20; seed = ++_i) {
            _results.push(finances.testScenario(seed));
          }
          return _results;
        })();
      });
      it('should have payments', function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = scenarios.length; _i < _len; _i++) {
          s = scenarios[_i];
          _results.push(expect(s.totalPayments).toBeGreaterThan(0));
        }
        return _results;
      });
      it('should have all items paid for', function() {
        var p, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = scenarios.length; _i < _len; _i++) {
          s = scenarios[_i];
          expect(s.totalPayments).toBe(findSum((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = s.items;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              i = _ref1[_j];
              _results1.push(i.amount);
            }
            return _results1;
          })()));
          expect(s.payments.length >= s.items.length).toBeTruthy();
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = s.items;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              i = _ref1[_j];
              _results1.push(expect(findSum((function() {
                var _k, _len2, _ref2, _results2;
                _ref2 = s.getPaymentsForItem(i);
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })())).toBe(i.amount));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should have every account at least either a payer or a user', function() {
        var a, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = scenarios.length; _i < _len; _i++) {
          s = scenarios[_i];
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = s.accounts;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              a = _ref1[_j];
              _results1.push(expect(a.usesItems.length || a.sendsPayments.length).toBeGreaterThan(0));
            }
            return _results1;
          })());
        }
        return _results;
      });
      return it("should transform to one in which the net amount\nthat each account pays is equal", function() {
        var a, fairShare, p, share, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = scenarios.length; _i < _len; _i++) {
          s = scenarios[_i];
          s.createInternalPayments();
          s.simplifyPayments();
          fairShare = s.totalPayments / s.accounts.length;
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = s.accounts.length;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              a = _ref1[_j];
              share = findSum(((function() {
                var _k, _len2, _ref2, _results2;
                _ref2 = a.sendsPayments;
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })()) - findSum((function() {
                var _k, _len2, _ref2, _results2;
                _ref2 = a.receivesPayments;
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  p = _ref2[_k];
                  _results2.push(p.amount);
                }
                return _results2;
              })()));
              _results1.push(expect(share).toEqual(fairShare));
            }
            return _results1;
          })());
        }
        return _results;
      });
    });
  });

}).call(this);
